data <- data %>%
dplyr::distinct(Entrez, Contrast, .keep_all = TRUE)
# Run KEGG enrichment with parallelization
cat("Running KEGG enrichment analysis with ", n_cores, " cores...\n", sep = "")
if (n_cores > 1) {
if (!requireNamespace("BiocParallel", quietly = TRUE)) {
stop("Package 'BiocParallel' is required for parallelization")
}
BiocParallel::register(BiocParallel::MulticoreParam(workers = n_cores))
} else {
BiocParallel::register(BiocParallel::SerialParam())
}
kegg_res <- clusterProfiler::compareCluster(
Entrez ~ Contrast,
data = data,
fun = "enrichKEGG",
universe = na.omit(universe_entrez),
organism = organism,
keyType = "ncbi-geneid",
pvalueCutoff = significance_threshold
)
# Handle no results
if (is.null(kegg_res) || nrow(kegg_res@compareClusterResult) == 0) {
return(.create_empty_kegg_plot())
}
# Ensure clusters are ordered correctly
kegg_res@compareClusterResult$Cluster <- factor(
kegg_res@compareClusterResult$Cluster,
levels = contrast_order
)
# Filter by significance
filtered_results <- subset(
kegg_res@compareClusterResult,
p.adjust <= significance_threshold
)
if (nrow(filtered_results) == 0) {
return(.create_empty_kegg_plot())
}
# Map Entrez IDs to gene symbols (parallelized)
cat("Mapping gene symbols...\n")
filtered_results <- .add_gene_symbols_parallel(
filtered_results,
org_db,
de_results_df,
n_cores
)
# Save filtered KEGG results for download
download_kegg_results <- filtered_results %>%
dplyr::select(Cluster, Description, p.adjust, GeneSymbols, dplyr::everything())
# Identify top KEGG pathways for plotting
top_KEGG_terms <- filtered_results %>%
dplyr::group_by(Cluster) %>%
dplyr::arrange(p.adjust, .by_group = TRUE) %>%
dplyr::slice_head(n = top_n) %>%
dplyr::ungroup() %>%
dplyr::pull(Description) %>%
unique()
# Filter for plotting
kegg_res@compareClusterResult <- filtered_results %>%
dplyr::filter(Description %in% top_KEGG_terms)
# Convert GeneRatio to numeric
kegg_res@compareClusterResult <- kegg_res@compareClusterResult %>%
dplyr::mutate(GeneRatio = sapply(strsplit(as.character(GeneRatio), "/"),
function(x) as.numeric(x[1]) / as.numeric(x[2])))
# Reorder KEGG terms using hierarchical clustering
kegg_res@compareClusterResult <- .reorder_GO_terms(kegg_res@compareClusterResult)
# Create size categories for GeneRatio
bin_breaks <- c(0, 0.01, 0.05, 0.10, max(kegg_res@compareClusterResult$GeneRatio, na.rm = TRUE) + 0.01)
bin_labels <- c("<=0.01", "0.01 - 0.05", "0.05 - 0.10", ">=0.10")
size_mapping <- c("<=0.01" = 2, "0.01 - 0.05" = 4, "0.05 - 0.10" = 6, ">=0.10" = 8)
kegg_res@compareClusterResult <- kegg_res@compareClusterResult %>%
dplyr::mutate(GeneRatioCategory = cut(GeneRatio, breaks = bin_breaks,
labels = bin_labels, include.lowest = TRUE, right = FALSE))
# Create plot labels and tooltips
kegg_res@compareClusterResult <- kegg_res@compareClusterResult %>%
dplyr::mutate(
p.adjust = as.numeric(as.character(p.adjust)),
GeneRatio = as.numeric(as.character(GeneRatio)),
plot_label = ifelse(
sapply(strsplit(as.character(Description), " "), length) > 6,
sapply(strsplit(as.character(Description), " "), function(words) {
paste(c(words[1:3], "...", tail(words, 3)), collapse = " ")
}),
as.character(Description)
)
) %>%
dplyr::mutate(
tooltip_text = paste(
"Cluster: ", as.character(Cluster), "<br>",
"KEGG Pathway: ", as.character(Description), "<br>",
"p.adjust: ", signif(p.adjust, 3), "<br>",
"GeneRatio: ", signif(GeneRatio, 3), "<br>",
"Top Genes:<br>", as.character(GeneSymbols)
)
)
# Create interactive plot
p <- ggplot2::ggplot(kegg_res@compareClusterResult, ggplot2::aes(
x = Cluster,
y = plot_label,
size = GeneRatioCategory,
color = p.adjust,
text = tooltip_text
)) +
ggplot2::geom_point(alpha = 0.8) +
ggplot2::scale_size_manual(name = "Gene Ratio", values = size_mapping) +
ggplot2::scale_color_gradient(low = "red", high = "blue",
limits = c(min(kegg_res@compareClusterResult$p.adjust, na.rm = TRUE),
max(kegg_res@compareClusterResult$p.adjust, na.rm = TRUE)),
name = "p.adjust") +
ggplot2::guides(color = ggplot2::guide_colorbar(title = "p.adjust")) +
ggplot2::ggtitle("KEGG Pathway Enrichment") +
ggplot2::xlab("Gene List") +
ggplot2::ylab("KEGG Pathway") +
ggplot2::theme_minimal() +
ggplot2::theme(
plot.title = ggplot2::element_text(size = 16, face = "bold"),
axis.text.x = ggplot2::element_text(size = 10, angle = 45, hjust = 1),
axis.title.x = ggplot2::element_text(size = 14),
legend.title = ggplot2::element_text(size = 12),
legend.text = ggplot2::element_text(size = 10)
)
# Convert to interactive
interactive_plot <- plotly::ggplotly(p, tooltip = "text") %>%
plotly::layout(legend = list(title = list(text = "Gene Ratio")))
# Static high-resolution plot
static_plot <- clusterProfiler::dotplot(kegg_res, showCategory = top_n) +
ggplot2::ggtitle("KEGG Pathway Enrichment") +
ggplot2::theme_minimal() +
ggplot2::theme(
plot.title = ggplot2::element_text(size = 16, face = "bold"),
axis.text.x = ggplot2::element_text(size = 10, angle = 45, hjust = 1),
axis.title.x = ggplot2::element_text(size = 14),
legend.title = ggplot2::element_text(size = 12),
legend.text = ggplot2::element_text(size = 10)
)
return(list(
interactive_plot = interactive_plot,
static_plot = static_plot,
kegg_results = download_kegg_results
))
}
#' @keywords internal
.create_empty_kegg_plot <- function() {
message_plot <- ggplot2::ggplot() +
ggplot2::annotate("text", x = 1, y = 1,
label = "No significant KEGG enrichment found",
size = 6, hjust = 0.5) +
ggplot2::theme_void() +
ggplot2::ggtitle("KEGG Pathway Enrichment")
return(list(
interactive_plot = plotly::ggplotly(message_plot),
static_plot = message_plot,
kegg_results = NULL
))
}
n_cores=4
# Run KEGG enrichment with error handling
kegg_results <- tryCatch({
generate_kegg_enrichment_plot_atac(
gene_lists = enrichment_data$gene_lists,
de_results_df = enrichment_data$results_df,
universe_entrez = enrichment_data$universe,
org_db = enrichment_data$org_db,
organism = report_params$organism,
n_cores = n_cores
)
}, error = function(e) {
message("[INFO] KEGG enrichment failed: ", e$message)
NULL
})
# Only proceed if kegg_results is not NULL
if (!is.null(kegg_results) && !is.null(kegg_results$kegg_results)) {
download_button_png(kegg_results$static_plot, "kegg_enrichment_plot", height = 12)
kegg_results$interactive_plot
# Download results
kegg_results$kegg_results %>%
mutate(GeneSymbols = gsub("<br>", "/", GeneSymbols)) %>%
downloadthis::download_this(
output_name = paste(report_params$seqID, "KEGG_results", sep = "_"),
output_extension = ".xlsx",
button_label = "Download KEGG enrichment results for all contrasts",
button_type = "primary",
has_icon = TRUE,
icon = "fa fa-save"
)
} else {
cat("### KEGG enrichment was not available for this dataset due to too few DA peaks.\n")
}
kegg_results$interactive_plot
# Only proceed if kegg_results is not NULL
if (!is.null(kegg_results) && !is.null(kegg_results$kegg_results)) {
# Display static plot download button
download_button_png(kegg_results$static_plot, "kegg_enrichment_plot", height = 12)
# Display interactive plot (needs explicit print in control flow)
print(kegg_results$interactive_plot)
# Download results
kegg_results$kegg_results %>%
mutate(GeneSymbols = gsub("<br>", "/", GeneSymbols)) %>%
downloadthis::download_this(
output_name = paste(report_params$seqID, "KEGG_results", sep = "_"),
output_extension = ".xlsx",
button_label = "Download KEGG enrichment results for all contrasts",
button_type = "primary",
has_icon = TRUE,
icon = "fa fa-save"
)
} else {
cat("### KEGG enrichment was not available for this dataset due to too few DA peaks.\n")
}
devtools::document()
devtools::install()
getwd()
source("/blue/cancercenter-dept/hkates/github-clones/app-atacreportR/scripts/rmd-helpers.R")
params_path <- "/blue/zhangw/BCBSR_BIOINFORMATICS/hkates/TANZIA/MLH1MSH2/NS3842_atacseq/MSH2/diff-analysis/output/NS3842-MSH2-from-app_params.txt"
library(DESeq2) #used in load data
library(dplyr) # used
library(htmltools) # used
library(DT) # used
library(stringr) # used
library(downloadthis) # used
library(atacreportR) # used
report_params <- parse_params(params_file_to_use)
report_params <- parse_params(params_path)
report_params
dds <- report_params$dds_file
dds  <- prepare_analysis_data_from_params(report_params)
dds
colData(dds)
rowData(dds)
assay(dds)
# We will perform DA analysis using edgeR, so we convert to a DGEList and perform TMM normalization while doing so
dge <- dds_to_dgelist(dds, norm_method = "TMM")
dge$genes
View(dge)
View(dge)
# Plot PCA - this plots LCPM and uses the TMM normalization factors
plot_pca(dge, title = "PCA", show_legend = TRUE,plot_var="condition")
#' @param title Character string for plot title
#' @param show_legend Logical; whether to show legend
#' @param plot_var Character string specifying which variable to color by
#'
#' @return List with plot object and title
#'
#' @importFrom edgeR cpm
#' @importFrom plotly plot_ly add_trace add_polygons layout
#' @importFrom car dataEllipse
#' @export
plot_pca <- function(dge, title, show_legend = TRUE, plot_var) {
# Avoid NSE warnings
PC1 <- PC2 <- Group <- Sample <- NULL
logcpm <- cpm(dge, log = TRUE)
finite_genes <- apply(logcpm, 1, function(x) all(is.finite(x)))
logcpm_clean <- logcpm[finite_genes, ]
pca_res <- prcomp(t(logcpm_clean), center = TRUE, scale. = FALSE)
scores <- as.data.frame(pca_res$x[, 1:2])
percentVar <- round(100 * pca_res$sdev^2 / sum(pca_res$sdev^2), 2)
samples_df <- as.data.frame(dge$samples)
scores$Sample <- rownames(scores)
scores$Group <- samples_df[[plot_var]]
fig <- plotly::plot_ly()
# Add ellipses
for (group in unique(scores$Group)) {
group_data <- scores[scores$Group == group, ]
if (nrow(group_data) >= 2) {
if (all(is.finite(group_data$PC1)) && all(is.finite(group_data$PC2))) {
tryCatch({
if (nrow(group_data) >= 3) {
ellipse_coords <- car::dataEllipse(group_data$PC1, group_data$PC2,
levels = 0.68, plot.points = FALSE, draw = FALSE)
} else {
hull_indices <- chull(group_data$PC1, group_data$PC2)
ellipse_coords <- as.matrix(group_data[hull_indices, c("PC1", "PC2")])
center_x <- mean(ellipse_coords[,1])
center_y <- mean(ellipse_coords[,2])
ellipse_coords[,1] <- center_x + (ellipse_coords[,1] - center_x) * 1.5
ellipse_coords[,2] <- center_y + (ellipse_coords[,2] - center_y) * 1.5
}
fig <- fig %>%
plotly::add_polygons(x = ellipse_coords[,1], y = ellipse_coords[,2],
name = paste(group, "CI"),
opacity = 0.2,
showlegend = FALSE,
hoverinfo = "skip")
}, error = function(e) {
message("Skipping ellipse for group ", group, ": ", e$message)
})
}
}
}
fig <- fig %>%
plotly::add_trace(
data = scores,
x = ~PC1, y = ~PC2,
color = ~Group,
text = ~Sample,
type = 'scatter', mode = 'markers',
marker = list(size = 10),
hovertemplate = "%{text}<br>PC1: %{x:.2f}<br>PC2: %{y:.2f}<extra></extra>",
showlegend = show_legend
) %>%
plotly::layout(
title = list(text = title, font = list(size = 14)),
xaxis = list(title = paste0("PC1 (", percentVar[1], "%)")),
yaxis = list(title = paste0("PC2 (", percentVar[2], "%)")),
width = 500,
height = 400
)
return(list(plot = fig, title = title))
}
# Plot PCA - this plots LCPM and uses the TMM normalization factors
pca_result <- plot_pca(dge, title = "PCA", show_legend = TRUE,plot_var="condition")
# Plot PCA - this plots LCPM and uses the TMM normalization factors
pca_result <- plot_pca(dge, title = "PCA", show_legend = TRUE,plot_var="condition")
# Plot PCA - this plots LCPM and uses the TMM normalization factors
plot_pca(dge, title = "PCA", show_legend = TRUE,plot_var="condition")
#' @param title Character string for plot title
#' @param show_legend Logical; whether to show legend
#' @param plot_var Character string specifying which variable to color by
#'
#' @return List with plot object and title
#'
#' @importFrom edgeR cpm
#' @importFrom plotly plot_ly add_trace add_polygons layout
#' @importFrom car dataEllipse
#' @export
plot_pca <- function(dge, title, show_legend = TRUE, plot_var) {
# Avoid NSE warnings
PC1 <- PC2 <- Group <- Sample <- NULL
logcpm <- cpm(dge, log = TRUE)
finite_genes <- apply(logcpm, 1, function(x) all(is.finite(x)))
logcpm_clean <- logcpm[finite_genes, ]
pca_res <- prcomp(t(logcpm_clean), center = TRUE, scale. = FALSE)
scores <- as.data.frame(pca_res$x[, 1:2])
percentVar <- round(100 * pca_res$sdev^2 / sum(pca_res$sdev^2), 2)
samples_df <- as.data.frame(dge$samples)
scores$Sample <- rownames(scores)
scores$Group <- samples_df[[plot_var]]
fig <- plotly::plot_ly()
# Add ellipses
for (group in unique(scores$Group)) {
group_data <- scores[scores$Group == group, ]
if (nrow(group_data) >= 2) {
if (all(is.finite(group_data$PC1)) && all(is.finite(group_data$PC2))) {
tryCatch({
if (nrow(group_data) >= 3) {
ellipse_coords <- car::dataEllipse(group_data$PC1, group_data$PC2,
levels = 0.68, plot.points = FALSE, draw = FALSE)
} else {
hull_indices <- chull(group_data$PC1, group_data$PC2)
ellipse_coords <- as.matrix(group_data[hull_indices, c("PC1", "PC2")])
center_x <- mean(ellipse_coords[,1])
center_y <- mean(ellipse_coords[,2])
ellipse_coords[,1] <- center_x + (ellipse_coords[,1] - center_x) * 1.5
ellipse_coords[,2] <- center_y + (ellipse_coords[,2] - center_y) * 1.5
}
fig <- fig %>%
plotly::add_polygons(x = ellipse_coords[,1], y = ellipse_coords[,2],
name = paste(group, "CI"),
opacity = 0.2,
showlegend = FALSE,
hoverinfo = "skip")
}, error = function(e) {
message("Skipping ellipse for group ", group, ": ", e$message)
})
}
}
}
fig <- fig %>%
plotly::add_trace(
data = scores,
x = ~PC1, y = ~PC2,
color = ~Group,
text = ~Sample,
type = 'scatter', mode = 'markers',
marker = list(size = 10),
hovertemplate = "%{text}<br>PC1: %{x:.2f}<br>PC2: %{y:.2f}<extra></extra>",
showlegend = show_legend
) %>%
plotly::layout(
xaxis = list(title = paste0("PC1 (", percentVar[1], "%)")),
yaxis = list(title = paste0("PC2 (", percentVar[2], "%)")),
width = 500,
height = 400
)
return(list(plot = fig, title = title))
}
# Plot PCA - this plots LCPM and uses the TMM normalization factors
pca_result <- plot_pca(dge, title = "PCA", show_legend = TRUE,plot_var="condition")
library(atacreportR)
# Plot PCA - this plots LCPM and uses the TMM normalization factors
pca_result <- plot_pca(dge, title = "PCA", show_legend = TRUE,plot_var="condition")
devtools::document()
devtools::document()
devtools::install()
library(DESeq2) #used in load data
library(dplyr) # used
library(htmltools) # used
library(DT) # used
library(stringr) # used
library(downloadthis) # used
library(atacreportR) # used
params_path <- "/blue/zhangw/BCBSR_BIOINFORMATICS/hkates/TANZIA/MLH1MSH2/NS3842_atacseq/MSH2/diff-analysis/output/NS3842-MSH2-from-app_params.txt"
source("/blue/cancercenter-dept/hkates/github-clones/app-atacreportR/scripts/rmd-helpers.R")
report_params <- parse_params(params_path)
dds <- prepare_analysis_data_from_params(report_params)
# We will perform DA analysis using edgeR, so we convert to a DGEList and perform TMM normalization while doing so
dge <- dds_to_dgelist(dds, norm_method = "TMM")
# Plot PCA - this plots LCPM and uses the TMM normalization factors
pca_result <- plot_pca(dge, title = "PCA", show_legend = TRUE,plot_var="condition")
# Display with title
pca_result$plot %>%
plotly::layout(
title = list(text = pca_result$title, font = list(size = 14))
)
contrasts=report_params$contrasts
contrasts
# Explore the dge
# Add code including `dge$samples$norm.factors`
# peak annotations dge$genes
# Let's add a shortened annotation variable too
dge$genes$Annotation_short <- gsub(" .*", "", dge$genes[[anno_col]])
# Explore the dge
# Add code including `dge$samples$norm.factors`
# peak annotations dge$genes
# Let's add a shortened annotation variable too
dge$genes$Annotation_short <- gsub(" .*", "", dge$genes$Annotation)
?run_differential_analysis
results_list <- run_differential_analysis(
dge = dge,  # DGEList with annotations already in dge$genes
contrasts = contrasts,
min_count = report_params$min_count_for_filtering,
min_prop = report_params$min_prop_for_filtering
)
# Check out the resuls list, it is just a list of tables of results, one per contrast
names(results_list)
colnames(results_list$KO_vs_R4)
# How many peaks are more accessible in KO relative to R4?
nrow(results_list$KO_vs_R4 %>% filter(FDR < 0.05) %>% filter(logFC > 1))
# How many peaks are more accessible in KO relative to R4?
nrow(results_list$KO_vs_R4$table %>% filter(FDR < 0.05) %>% filter(logFC > 1))
# How many of these are in promoters?
nrow(results_list$KO_vs_R4$table %>% filter(FDR < 0.05) %>% filter(logFC > 1) %>% abs(Distance.to.Tss) < 1000)
# How many of these are in promoters?
nrow(results_list$KO_vs_R4$table %>% filter(FDR < 0.05) %>% filter(logFC > 1) %>% abs(Distance.to.TSS) < 1000)
# How many of these are in promoters?
nrow(results_list$KO_vs_R4$table %>% filter(FDR < 0.05) %>% filter(logFC > 1) %>% abs(Distance.to.TSS) < 1000)
# How many of these are in promoters?
nrow(results_list$KO_vs_R4$table %>% filter(FDR < 0.05) %>% filter(logFC > 1) %>% filter(abs(Distance.to.TSS) < 1000))
plot_volcano(
results_list = results_list,
sig_cutoff = report_params$sig_cutoff,
logfc_cutoff = report_params$logFC_cutoff
)
report_params$sig_cutoff
print(plot_volcano(
results_list = results_list,
sig_cutoff = 0.05,
logfc_cutoff = 1
))
print(plot_volcano(
results_list = results_list$KO_vs_R4$table,
sig_cutoff = 0.05,
logfc_cutoff = 1
))
print(plot_volcano(
results_list = results_list$KO_vs_R4$table,
sig_cutoff = 0.05,
logfc_cutoff = 1
))
# Let's visualize our results in a volcano plot. This will plot one per contrast.
library(htmltools)
tagList(
plot_volcano(results_list, sig_cutoff = 0.05, logfc_cutoff = 1),
#  plot_ma(results_list, sig_cutoff = 0.05, logfc_cutoff = 1)
)
tagList(
plot_volcano(results_list, sig_cutoff = 0.05, logfc_cutoff = 1),
#  plot_ma(results_list, sig_cutoff = 0.05, logfc_cutoff = 1)
)
report_params$organism
enrichment_data <- prepare_gene_lists_for_enrichment(
results_list = results_list,
organism = "hsa",
sig_cutoff = 0.05,
logfc_cutoff = 1
)
# Extract components for downstream use
gene_list_named <- enrichment_data$gene_lists
de_results_df <- enrichment_data$results_df
universe_entrez <- enrichment_data$universe
org_db <- enrichment_data$org_db
View(de_results_df)
enrichment_data$org_db
# Perform GO Enrichment for Biological Processes
GO_BP_results <- generate_enrichment_plot_atac(
gene_lists = enrichment_data$gene_lists,
de_results_df = enrichment_data$results_df,
universe_entrez = enrichment_data$universe,
org_db = enrichment_data$org_db,
ont_category = "BP",n_cores = 4
)
# View all the results in a df
GO_BP_results$go_results
# Use the same gene lists etc. for KEGG enrichment
kegg_results <- generate_kegg_enrichment_plot_atac(
gene_lists = enrichment_data$gene_lists,
de_results_df = enrichment_data$results_df,
universe_entrez = enrichment_data$universe,
org_db = enrichment_data$org_db,
organism = report_params$organism,
n_cores = 4
)
